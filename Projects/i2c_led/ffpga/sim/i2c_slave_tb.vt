// ---------------------------------------------------------------------------
// Â© 2024 Renesas Electronics
//
// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"),
// to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
// and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
// The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE
// OR OTHER DEALINGS IN THE SOFTWARE.
// ---------------------------------------------------------------------------
// Base Module Name: i2c_slave_tb
// Tool version:
//   Software: ForgeFPGA Workshop v.6.31
// Revision:
//   02.08.2022 r001 - New test bench design
//   09.15.2022 r002 - Code style review
//   10.29.2024 r003 - Update design
// ---------------------------------------------------------------------------

`timescale 1ns / 1ps

module i2c_slave_tb;

// Parameter declaration
parameter I2C_SLAVE_ADR = 7'h32;

localparam DATA_WIDTH = 8;
localparam R_CLK_PERIOD = 20;   // 50 MHz
localparam SCL_CLK = 10000;     // 100 KHz

// Signal declaration
reg                     r_clk     = 1'b0;
reg                     r_rst     = 1'b1;
reg                     r_en      = 1'b0;
reg  [DATA_WIDTH-1:0]   r_data_tx = 8'h00;
reg                     r_i_scl   = 1'b1;
reg                     r_i_sda   = 1'b1;
wire                    w_o_sda;
wire                    w_o_sda_oe;
wire [DATA_WIDTH-1:0]   w_data_rx;
wire                    w_busy;
wire                    w_int_tx;
wire                    w_int_rx;
reg                     r_start_scl = 1'b0;
reg                     r_pause_scl = 1'b0;
reg                     r_i_scl_shift = 1'b0;
reg [6:0]               r_addr_ic;
reg  [DATA_WIDTH-1:0]   r_i2c_data_tx = 8'h00;
reg  [DATA_WIDTH-1:0]   r_i2c_data_rx = 8'h00;

// Clock generation
always begin
    r_clk = 1'b0;
    #(R_CLK_PERIOD/2) r_clk = 1'b1;
    #(R_CLK_PERIOD/2);
end

// SCL generation
always begin
    if(r_start_scl) begin
        r_i_scl = 1'b0;
        #(SCL_CLK/2) r_i_scl = 1'b1;
        #(SCL_CLK/2);
    end else if(r_pause_scl) begin
        r_i_scl = 1'b0;
        #1;
    end else begin
        r_i_scl = 1'b1;
        #1;
    end
end

// 90 degree shifted SCL
always begin
    @(negedge r_i_scl);
    #(SCL_CLK/4) r_i_scl_shift = 1'b1;
    #(SCL_CLK/2) r_i_scl_shift = 1'b0;
end

// Reset initial
initial begin
    r_rst = 1'b1;
    #50;
    r_rst = 1'b0;
end

// Main Block
initial begin
    $dumpfile("i2c_slave_tb.vcd");
    $dumpvars(0, i2c_slave_tb);

    r_addr_ic = I2C_SLAVE_ADR;

    wait(!r_rst);
    #1000;
    r_en  <= 1'b1;
    #1000;

    // Single master read
    r_data_tx <= 8'hA5; // Data to be read
    start(1'b1);        // Set address IC and read operation
    data_r(r_i2c_data_tx, 1'b1);
    stop();
    if(r_data_tx == r_i2c_data_tx) begin
        $display ("Reading data was successful");
    end else begin
        $display ("Error reading data: Data from module = %0h; Read data = %0h", r_data_tx, r_i2c_data_tx);
    end
    #50000;

    // Single master write
    r_i2c_data_rx = 8'b01100101;
    start(1'b0);
    data_w(r_i2c_data_rx, 1'b1);
    stop();
    if(w_data_rx == r_i2c_data_rx) begin
        $display ("Reading data was successful");
    end else begin
        $display ("Error reading data: Data from module = %0h; Write data = %0h", w_data_rx, r_i2c_data_rx);
    end
    #50000;


    // Sequential master read
    r_data_tx <= 8'hA5;
    start(1'b1);
    data_r(r_i2c_data_tx, 1'b0);
    r_data_tx <= 8'h5A;
    data_r(r_i2c_data_tx, 1'b0);
    r_data_tx <= 8'h37;
    data_r(r_i2c_data_tx, 1'b1);
    stop();
    #50000;

    // Sequential master write
    start(1'b0);
    data_w(8'hA5, 1'b1);
    data_w(8'h5A, 1'b1);
    data_w(8'h37, 1'b1);
    stop();
    #50000;

    // Partial master read
    start(1'b0);
    data_w(8'h01, 1'b1);
    pause_scl_t();
    r_start_scl = 1'b0;
    r_pause_scl = 1'b0;
    #5000;
    start(1'b1);
    r_data_tx <= 8'hA5;
    data_r(r_i2c_data_tx, 1'b0);
    r_data_tx <= 8'h5A;
    data_r(r_i2c_data_tx, 1'b1);
    stop();
    #50000;

    // Partial master write
    start(1'b0);
    data_w(8'h10, 1'b1);
    pause_scl_t();
    r_start_scl = 1'b0;
    r_pause_scl = 1'b0;
    #5000;
    start(1'b0);
    data_w(8'hA5, 1'b1);
    data_w(8'h5A, 1'b1);
    stop();
    #50000;

    // Single master read, slave address is wrong
    r_addr_ic = 7'b0011000;
    start(1'b1);
    r_data_tx <= 8'hA5;
    data_r(r_i2c_data_tx, 1'b1);
    stop();
    #50000;

    // Single master write, slave address is wrong
    start(1'b0);
    data_w(8'h65, 1'b1);
    stop();
    #50000;

    // Single master write, packet interrupted
    r_addr_ic = I2C_SLAVE_ADR;
    start(1'b0);
    pause_scl_t();
    r_i_sda = 1'b0;
    @(posedge r_i_scl_shift);
    r_i_sda = 1'b1;
    @(posedge r_i_scl_shift);
    r_i_sda = 1'b0;
    stop();
    #50000;

    // Sequential master write, packet interrupted
    start(1'b0);
    data_w(8'hA5, 1'b1);
    pause_scl_t();
    r_i_sda = 1'b0;
    @(posedge r_i_scl_shift);
    r_i_sda = 1'b1;
    @(posedge r_i_scl_shift);
    r_i_sda = 1'b0;
    stop();
    #50000;

    #500 r_en  <= 1'b0;
    #50  r_rst <= 1'b1;
    #5000  $finish;
end

// Instantiate I2C module
i2c_slave #(
  .I2C_SLAVE_ADR (I2C_SLAVE_ADR)
) dut (
    .i_clk     (r_clk),
    .i_rst     (r_rst),
    .i_en      (r_en),
    .o_busy    (w_busy),
    .i_scl     (r_i_scl),
    .i_sda     (r_i_sda),
    .o_sda     (w_o_sda),
    .o_sda_oe  (w_o_sda_oe),
    .i_data_tx (r_data_tx),
    .o_data_rx (w_data_rx),
    .o_int_tx  (w_int_tx),
    .o_int_rx  (w_int_rx)
);

// Tasks

// Start sequence
task start (input reg wr_or_rd); // 1'b0 - master write, 1'b1 - master read
    begin
        r_i_sda = 1'b0;
        #(SCL_CLK/4);
        r_start_scl = 1'b1;
        addr(wr_or_rd);
    end
endtask

// Stop sequence
task stop();
    begin
        @(posedge r_i_scl_shift);
        r_i_sda = 1'b0;
        #(SCL_CLK/4);
        r_start_scl = 1'b0;
        #(SCL_CLK/4);
        r_i_sda = 1'b1;
    end
endtask

// Pause SCL
task pause_scl_t();
    begin
        r_start_scl = 1'b0;
        r_pause_scl = 1'b1;
        #25000;
        r_start_scl = 1'b1;
        r_pause_scl = 1'b0;
    end
endtask

// Master write address
task addr (input reg wr_or_rd);
    begin : ADDRESS
        integer i;
        for(i = 6; i >= 0; i=i-1) begin
            @(posedge r_i_scl_shift) r_i_sda = r_addr_ic[i];
        end
        if(!wr_or_rd) @(posedge r_i_scl_shift) r_i_sda = 1'b0;
        else @(posedge r_i_scl_shift) r_i_sda = 1'b1;
        @(posedge r_i_scl_shift) r_i_sda = 1'b1;
    end
endtask

// Data read
task data_r (output reg [DATA_WIDTH-1:0] data, input reg ack);
    begin : DATA_READ
        integer i;
        pause_scl_t();
        for(i = DATA_WIDTH-1; i >= 0; i=i-1) begin
            r_i_sda = ~w_o_sda_oe;
            data[i] = ~w_o_sda_oe;
            @(posedge r_i_scl_shift);
        end
        r_i_sda = ack;
    end
endtask

// Data write
task data_w (input reg [DATA_WIDTH-1:0] data, input reg ack);
    begin : DATA_WRITE
        integer i;
        pause_scl_t();
        for(i = DATA_WIDTH-1; i >= 0; i=i-1) begin
            r_i_sda = data[i];
            @(posedge r_i_scl_shift);
        end
        r_i_sda = ack;
    end
endtask

endmodule
